سوال 1-
تابع extract_even_digits:
 یک عدد را به عنوان ورودی می‌گیرد و یک رشته حاوی ارقام زوج جدا شده با * را برمی‌گرداند.
حلقه while:
 تا زمانی که عدد ورودی بزرگتر از صفر باشد تکرار می‌شود.
سوال 2_
فرمول علامت:
= (-1) ** (n-1)
فرمول صورت کسر:
= 2 * i + 1
فرمول مخرج کسر:
 i + 9 if i % 2 == 0 else -i + 10
سوال 5_
دو حلقه تو در تو ایجاد می‌شود: 
حلقه بیرونی برای کنترل شماره سطر است.
حلقه درونی برای چاپ اعداد در هر سطر استفاده می‌شود.
در هر تکرار حلقه درونی، حاصل‌ضرب شماره سطر در یک شمارنده (که از 1 شروع می‌شود و تا شماره سطر افزایش می‌یابد) محاسبه و چاپ می‌شود.
سوال 6_
از کاربر تعداد اعداد (n) را دریافت کنید.
یک لیست خالی برای ذخیره اعداد ایجاد کنید.
در یک حلقه، n بار از کاربر عدد دریافت کرده و آن را به لیست اضافه کنید.
بزرگ‌ترین، کوچک‌ترین و میانگین اعداد در لیست را محاسبه کنید.
انحراف استاندارد را با استفاده از فرمول محاسبه کنید.
نتایج محاسبات را نمایش دهید.
سوال 9: متغیرهای جهانی و محلی: کدهای P1، P2، P3 و P4 را اجرا کرده و خروجی ها را گزارش دهید. دلایل خروجی آنها را با جزئیات توضیح دهید.
توضیحات برنامه :
متغیرهای محلی (Local Variables):
داخل یک تابع تعریف می‌شوند.
فقط در داخل همان تابع قابل دسترسی هستند.
وقتی تابع اجرا می‌شود، متغیر محلی ایجاد می‌شود و وقتی تابع به پایان می‌رسد، متغیر از بین می‌رود.
متغیرهای سراسری (Global Variables):
خارج از هر تابع تعریف می‌شوند.
در کل برنامه قابل دسترسی هستند.
تغییرات در یک متغیر سراسری در همه قسمت‌های برنامه اعمال می‌شود.
 سوال 9-
متغیرهای محلی (Local Variables):
داخل یک تابع تعریف می‌شوند.
فقط در داخل همان تابع قابل دسترسی هستند.
وقتی تابع اجرا می‌شود، متغیر محلی ایجاد می‌شود و وقتی تابع به پایان می‌رسد، متغیر از بین می‌رود.
متغیرهای سراسری (Global Variables):
خارج از هر تابع تعریف می‌شوند.
در کل برنامه قابل دسترسی هستند.
تغییرات در یک متغیر سراسری در همه قسمت‌های برنامه اعمال می‌شود.
P1:
 تعریف تابع f:
این خط یک تابع با نام f تعریف می‌کند. توابع بلوک‌هایی از کد هستند که برای انجام کارهای خاص تعریف می‌شوند و می‌توان آن‌ها را چندین بار فراخوانی کرد.
متغیر محلی s:
داخل تابع f، متغیری به نام s تعریف شده و مقدار "I live in Khorramabad" به آن اختصاص داده شده است.
این متغیر یک متغیر محلی است، به این معنی که فقط داخل تابع f قابل دسترسی است و در خارج از آن قابل مشاهده نیست.
چاپ مقدار s:
دستور print(s) مقدار متغیر s را در خروجی چاپ می‌کند.
فراخوانی تابع f:
در قسمت اصلی برنامه، تابع f فراخوانی می‌شود. این باعث می‌شود که کدهای داخل تابع اجرا شوند.
نکات مهم:
متغیرهای محلی به حافظه اختصاص داده می‌شوند زمانی که تابع فراخوانی می‌شود و هنگامی که تابع به پایان می‌رسد، از حافظه آزاد می‌شوند.
استفاده از متغیرهای محلی باعث می‌شود که کدهای شما بهتر سازماندهی شده و خواناتر شوند. از ایجاد متغیرهای سراسری به جای متغیرهای محلی خودداری کنید، زیرا استفاده بیش از حد از متغیرهای سراسری می‌تواند منجر به مشکلات در برنامه‌های بزرگتر شود.
P2:
این کد شباهت زیادی به کد P1 دارد با این تفاوت که در انتهای برنامه سعی شده است تا متغیر s را خارج از تابع چاپ کنیم.
تعریف تابع f:
همانند کد P1، یک تابع با نام f تعریف می‌شود که یک متغیر محلی به نام s دارد و مقدار آن را چاپ می‌کند.
فراخوانی تابع f:
تابع f فراخوانی می‌شود و خروجی "Inside Function: I live in Khorramabad" را تولید می‌کند.
تلاش برای چاپ s خارج از تابع:
در خط آخر، سعی شده است تا مقدار متغیر s را خارج از تابع چاپ کنیم. اما این خط باعث ایجاد خطا می‌شود.
چرا خطا رخ می‌دهد؟
دامنه متغیرهای محلی: متغیر s یک متغیر محلی است و فقط داخل تابع f قابل دسترسی است. هنگامی که اجرای تابع f به پایان می‌رسد، متغیر s از حافظه حذف می‌شود و دیگر قابل دسترسی نیست.
خطای NameError: تلاش برای دسترسی به متغیری که تعریف نشده است، باعث ایجاد خطای NameError می‌شود.
خروجی نهایی:
خروجی این کد تنها خط "Inside Function: I live in Khorramabad" خواهد بود که مربوط به چاپ داخل تابع است. خط بعدی که سعی در چاپ s خارج از تابع دارد، باعث ایجاد خطا می‌شود.
نتیجه‌گیری:
این مثال به وضوح نشان می‌دهد که متغیرهای محلی تنها در محدوده تابعی که تعریف شده‌اند قابل دسترسی هستند و تلاش برای دسترسی به آن‌ها خارج از آن تابع باعث ایجاد خطا می‌شود. این مفهوم بسیار مهم در برنامه‌نویسی است و باید به خوبی درک شود تا از بروز خطاهای غیرمنتظره جلوگیری شود.
نکات کلیدی:
متغیرهای محلی فقط در داخل تابعی که تعریف شده‌اند قابل دسترسی هستند.
تلاش برای دسترسی به متغیر محلی خارج از تابع باعث ایجاد خطای NameError می‌شود.
استفاده از متغیرهای محلی باعث می‌شود که کدهای شما بهتر سازماندهی شده و خواناتر شوند.
P3:
این کد به بررسی نحوه استفاده از متغیرهای سراسری و محلی در پایتون می‌پردازد.
تعریف تابع f:
یک تابع به نام f تعریف می‌شود. در ابتدای تابع، از کلمه کلیدی global s استفاده شده است. این به پایتون می‌گوید که متغیر s که در داخل تابع استفاده می‌شود، همان متغیری است که در خارج از تابع نیز تعریف شده و یک متغیر سراسری است.
مقدار متغیر s به "I live in Khorramabad." تغییر می‌کند.
مقدار جدید s چاپ می‌شود.
بخش اصلی برنامه:
در ابتدا، یک متغیر سراسری به نام s تعریف شده و مقدار "I live in Iran." به آن اختصاص داده می‌شود.
سپس، تابع f فراخوانی می‌شود.در نهایت، مقدار نهایی متغیر سراسری s دوباره چاپ می‌شود.
توضیح خروجی:
هنگامی که تابع f فراخوانی می‌شود، به دلیل استفاده از کلمه کلیدی global، مقدار متغیر سراسری s به "I live in Khorramabad." تغییر می‌کند. سپس، این مقدار جدید چاپ می‌شود.
پس از پایان اجرای تابع، مقدار نهایی متغیر سراسری s که در بخش اصلی برنامه تغییر کرده است، دوباره چاپ می‌شود که همان "I live in Khorramabad." است.
چرا خروجی به این صورت است؟
استفاده از global s باعث می‌شود که هر تغییری که در متغیر s داخل تابع ایجاد شود، بر روی متغیر سراسری s نیز تأثیر بگذارد.
بنابراین، هنگامی که مقدار s داخل تابع به "I live in Khorramabad." تغییر می‌کند، این تغییر در سراسر برنامه اعمال می‌شود.
نکات مهم:
استفاده از global به طور گسترده توصیه نمی‌شود، زیرا می‌تواند باعث ایجاد کدهای پیچیده و دشوار برای اشکال‌زدایی شود.
بهتر است از متغیرهای محلی استفاده کنید و فقط در مواقع ضروری از متغیرهای سراسری استفاده کنید.
استفاده بیش از حد از متغیرهای سراسری می‌تواند منجر به تداخل بین بخش‌های مختلف برنامه شود.
جمع‌بندی:
متغیرهای سراسری در کل برنامه قابل دسترسی هستند.
با استفاده از کلمه کلیدی global می‌توان به یک متغیر سراسری از داخل یک تابع دسترسی پیدا کرد و آن را تغییر داد.
استفاده بیش از حد از متغیرهای سراسری می‌تواند باعث پیچیدگی و مشکلات در برنامه شود.
بهتر است از متغیرهای محلی استفاده کنید و فقط در مواقع ضروری از متغیرهای سراسری استفاده کنید.
P4:
این کد شباهت زیادی به کدهای قبلی دارد، اما تفاوت کلیدی آن در نحوه استفاده از متغیر s داخل تابع است.
تعریف تابع f:
یک تابع به نام f تعریف می‌شود. داخل تابع، متغیری به نام s تعریف شده و مقدار "I live in Khorramabad." به آن اختصاص داده شده است. سپس، مقدار s چاپ می‌شود.
بخش اصلی برنامه:
در ابتدا، یک متغیر به نام s تعریف شده و مقدار "I live in Iran." به آن اختصاص داده می‌شود. سپس، تابع f فراخوانی می‌شود.
در نهایت، مقدار نهایی متغیر s دوباره چاپ می‌شود.
توضیح خروجی:
هنگامی که تابع f فراخوانی می‌شود، یک متغیر محلی به نام s داخل تابع ایجاد می‌شود و مقدار "I live in Khorramabad." به آن اختصاص داده می‌شود. سپس، این مقدار جدید چاپ می‌شود.
پس از پایان اجرای تابع، به بخش اصلی برنامه برمی‌گردیم. در اینجا، متغیر سراسری s که مقدار "I live in Iran." دارد، دوباره چاپ می‌شود.
چرا خروجی به این صورت است؟
در این کد، از کلمه کلیدی global استفاده نشده است. بنابراین، متغیر s داخل تابع f یک متغیر محلی است و تغییرات آن بر روی متغیر سراسری s تأثیری ندارد.
متغیر محلی s داخل تابع، یک کپی از متغیر سراسری s نیست. این دو متغیر کاملاً جدا از هم هستند و هر کدام فضای حافظه جداگانه‌ای را اشغال می‌کنند.
تفاوت با کد P3:
در کد P3، با استفاده از global s، متغیر s داخل تابع به متغیر سراسری اشاره می‌کرد و هر تغییری در آن، بر روی متغیر سراسری نیز تأثیر می‌گذاشت.
در این کد (P4)، متغیر s داخل تابع یک متغیر محلی است و تغییرات آن بر روی متغیر سراسری تأثیری ندارد.
نکات کلیدی:
اگر می‌خواهید تغییرات یک متغیر داخل تابع، بر روی متغیر سراسری تأثیر بگذارد، باید از کلمه کلیدی global استفاده کنید.
اگر از global استفاده نکنید، متغیر داخل تابع یک متغیر محلی است و تغییرات آن بر روی متغیر سراسری تأثیری ندارد.
اگر می‌خواهید در داخل یک تابع، مقدار یک متغیر سراسری را تغییر دهید، باید از global استفاده کنید.
اگر می‌خواهید یک متغیر جدید ایجاد کنید که فقط داخل تابع قابل دسترسی باشد، نیازی به استفاده از global نیست.
سوال 10: مطالعه توابع بازگشتی در پایتون .با جزئیات توضیح دهید که چگونه تابع بازگشتی زیر کار می کند؟
توضیحات برنامه : 
این کد یک تابع بازگشتی به نام factorial را تعریف می‌کند که فاکتوریل یک عدد را محاسبه می‌کند.
تابع بازگشتی چیست؟ تابعی است که در تعریف خود، به خودش ارجاع می‌دهد. یعنی در داخل بدنه تابع، خود تابع دوباره فراخوانی می‌شود. این نوع توابع برای حل مسائلی که می‌توان آن‌ها را به زیرمسائل کوچکتر و مشابه تقسیم کرد، بسیار مفید هستند.
تعریف تابع:
def factorial(x): : این خط یک تابع با نام factorial تعریف می‌کند که یک پارامتر به نام x می‌گیرد.
شرط پایه:
if x == 1: : اگر مقدار x برابر با 1 باشد، تابع به صورت مستقیم عدد 1 را برمی‌گرداند. این شرط پایه است که به فراخوانی‌های بازگشتی پایان می‌دهد و از ایجاد یک حلقه بی‌نهایت جلوگیری می‌کند. زیرا فاکتوریل عدد 1 برابر با 1 است.
حالت بازگشتی:
else: : اگر x بزرگتر از 1 باشد، وارد این بخش می‌شویم.
return (x * factorial(x-1)): : در این قسمت، تابع خود را با آرگومان x-1 فراخوانی می‌کند. این یعنی برای محاسبه فاکتوریل x، ابتدا فاکتوریل x-1 را محاسبه کرده و سپس نتیجه را در x ضرب می‌کند. این فرایند تا زمانی ادامه می‌یابد که به شرط پایه برسیم.
مثال: محاسبه فاکتوریل 4 وقتی factorial(4) را فراخوانی می‌کنیم، اتفاقات زیر رخ می‌دهد:
factorial(4) فراخوانی می‌شود.
از آنجایی که 4 بزرگ‌تر از 1 است، به بخش else می‌رود و 4 * factorial(3) را محاسبه می‌کند.
factorial(3) فراخوانی می‌شود و همین روند تکرار می‌شود تا به factorial(1) برسیم.
factorial(1) به شرط پایه می‌رسد و 1 را برمی‌گرداند.
نتایج بازگشتی به ترتیب در هم ضرب می‌شوند: 
factorial(2) = 2 * 1 = 2
factorial(3) = 3 * 2 = 6
factorial(4) = 4 * 6 = 24
در نهایت، تابع مقدار 24 را برمی‌گرداند که همان فاکتوریل 4 است.
نحوه کار تابع بازگشتی: تابع بازگشتی به صورت تودرتو خود را فراخوانی می‌کند تا به یک جواب برسد. هر فراخوانی جدید، یک کپی از تابع با مقادیر متفاوت برای پارامتر ایجاد می‌کند. این فراخوانی‌ها تا زمانی ادامه می‌یابد که به شرط پایه برسند و سپس نتایج به صورت بازگشتی به فراخوانی‌های قبلی برگردانده می‌شوند.
مزایای توابع بازگشتی:
خوانایی کد: در بسیاری از موارد، توابع بازگشتی کد را خواناتر و قابل درک‌تر می‌کنند.
حل مسائل پیچیده: توابع بازگشتی برای حل مسائلی که به صورت بازگشتی تعریف می‌شوند، بسیار مناسب هستند.
معایب توابع بازگشتی:
مصرف حافظه: فراخوانی‌های بازگشتی متعدد می‌توانند باعث مصرف زیاد حافظه شوند.
-پیچیدگی در پیاده‌سازی: برخی از الگوریتم‌ها ممکن است با استفاده از حلقه‌های تکراری به صورت ساده‌تری پیاده‌سازی شوند.
